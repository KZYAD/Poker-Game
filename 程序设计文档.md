# 扑克游戏程序设计文档

## 一、项目概述

本项目是基于 Cocos2d-x 3.17 开发的扑克消除游戏，采用 MVC 架构设计，实现了卡牌匹配消除和撤销功能。

### 开发环境
- **引擎版本**: Cocos2d-x 3.17
- **开发语言**: C++
- **设计分辨率**: 1080 x 2080
- **Python解释器**: C:\Python27\python.exe (用于cocos命令行工具)

## 二、架构设计

### 2.1 MVC架构概述

项目严格遵循MVC架构模式，将视图、逻辑和数据分离，确保代码的可维护性和可扩展性。

### 2.2 目录结构

```
Classes/
├── configs/           # 静态配置相关类
│   ├── models/       # 配置数据模型
│   │   ├── CardResConfig.h/cpp      # 卡牌资源配置
│   │   └── LevelConfig.h/cpp        # 关卡配置
│   └── loaders/      # 配置加载器
│       └── LevelConfigLoader.h/cpp  # 关卡配置加载器
│
├── models/           # 运行时动态数据模型
│   ├── CardModel.h/cpp              # 卡牌数据模型
│   ├── GameModel.h/cpp              # 游戏数据模型
│   └── UndoModel.h/cpp              # 撤销数据模型
│
├── views/            # 视图层
│   ├── CardView.h/cpp               # 卡牌视图
│   └── GameView.h/cpp               # 游戏主视图
│
├── controllers/      # 控制器层
│   └── GameController.h/cpp         # 游戏控制器
│
├── managers/         # 管理器层
│   └── UndoManager.h/cpp            # 撤销管理器
│
├── services/         # 服务层
│   └── GameModelGenerator.h/cpp     # 游戏数据生成服务
│
└── utils/            # 工具类
    └── CardMatchUtils.h/cpp         # 卡牌匹配工具
```

## 三、核心模块设计

### 3.1 Configs层 - 静态配置

#### CardResConfig (卡牌资源配置)
**职责**: 管理卡牌显示所需的图片资源路径

**核心方法**:
- `getCardBackPath()`: 获取卡牌背面图片
- `getCardSuitPath(int suit)`: 获取花色图片
- `getCardBigNumberPath(int face, bool isRed)`: 获取大数字图片
- `getCardSmallNumberPath(int face, bool isRed)`: 获取小数字图片

#### LevelConfig (关卡配置)
**职责**: 存储关卡的静态配置信息

**数据结构**:
```cpp
struct CardConfigData {
    int cardFace;              // 牌面点数
    int cardSuit;              // 花色
    cocos2d::Vec2 position;    // 位置
};
```

#### LevelConfigLoader (关卡配置加载器)
**职责**: 从JSON文件加载关卡配置

**核心方法**:
- `loadLevelConfig(int levelId)`: 加载指定关卡配置
- `parseLevelConfig(const string& jsonStr)`: 解析JSON配置

### 3.2 Models层 - 数据模型

#### CardModel (卡牌数据模型)
**职责**: 存储单张卡牌的运行时数据

**数据枚举**:
```cpp
enum CardSuitType {     // 花色
    CST_CLUBS,          // 梅花
    CST_DIAMONDS,       // 方块
    CST_HEARTS,         // 红桃
    CST_SPADES          // 黑桃
};

enum CardFaceType {     // 点数
    CFT_ACE, CFT_TWO, ... CFT_KING
};
```

**核心属性**:
- `_id`: 卡牌唯一ID
- `_face`: 卡牌点数
- `_suit`: 卡牌花色
- `_position`: 卡牌位置

**核心方法**:
- `isRed()`: 判断是否为红色花色
- `getFaceValue()`: 获取点数数值

#### GameModel (游戏数据模型)
**职责**: 存储整个游戏的运行时数据

**核心属性**:
- `_playfieldCards`: 主牌区卡牌列表
- `_stackCards`: 备用牌堆卡牌列表
- `_trayCard`: 底牌
- `_cardMap`: 卡牌ID映射表(用于快速查找)

**核心方法**:
- `findCardById(int cardId)`: 根据ID查找卡牌
- `removePlayfieldCard/addPlayfieldCard`: 管理主牌区卡牌
- `removeStackCard/addStackCard`: 管理备用牌堆卡牌

#### UndoModel (撤销数据模型)
**职责**: 记录一次操作的所有必要信息，用于撤销

**操作类型**:
```cpp
enum UndoActionType {
    UAT_PLAYFIELD_TO_TRAY,   // 主牌区到底牌
    UAT_STACK_TO_TRAY        // 备用牌堆到底牌
};
```

**核心属性**:
- `_actionType`: 操作类型
- `_cardId`: 移动的卡牌ID
- `_previousTrayCardId`: 之前的底牌ID
- `_originalPosition`: 卡牌原始位置

### 3.3 Views层 - 视图组件

#### CardView (卡牌视图)
**职责**: 负责单张卡牌的UI显示和交互

**核心特性**:
- 持有`const CardModel*`指针(只读)
- 通过回调函数与Controller通信
- 支持移动动画
- 可控制是否可点击

**核心方法**:
- `create(const CardModel*, callback)`: 创建卡牌视图
- `playMoveAnimation(targetPos, duration, callback)`: 播放移动动画
- `setClickEnabled(bool)`: 设置是否可点击

**UI组成**:
- 卡牌背景
- 花色图标
- 大数字(中央)
- 小数字(左上角)

#### GameView (游戏主视图)
**职责**: 整个游戏界面的显示

**区域划分**:
- 主牌区 (高度: 1500px)
- 底牌区 (高度: 580px)
- 备用牌堆区
- UI按钮区

**核心方法**:
- `create(gameModel, callbacks...)`: 创建游戏视图
- `getCardView(cardId)`: 获取卡牌视图
- `updateTrayCardView(cardView)`: 更新底牌显示
- `getTrayPosition() / getStackPosition()`: 获取关键位置

### 3.4 Controllers层 - 控制器

#### GameController (游戏控制器)
**职责**: 协调Model和View，处理游戏核心逻辑

**核心成员**:
- `_gameModel`: 游戏数据模型
- `_gameView`: 游戏视图
- `_undoManager`: 撤销管理器

**核心方法**:
- `startGame(levelId, parentNode)`: 启动游戏
- `handlePlayfieldCardClick(cardId)`: 处理主牌区卡牌点击
- `handleStackCardClick(cardId)`: 处理备用牌堆点击
- `handleUndoClick()`: 处理撤销操作

**业务逻辑流程**:

1. **卡牌匹配流程**:
```
用户点击主牌区卡牌
    ↓
CardView捕获点击 → 触发回调
    ↓
GameController::handlePlayfieldCardClick
    ↓
检查是否可以与底牌匹配 (CardMatchUtils)
    ↓
记录撤销信息 (UndoManager)
    ↓
更新GameModel数据
    ↓
触发CardView动画
    ↓
动画完成后更新GameView
```

2. **撤销操作流程**:
```
用户点击撤销按钮
    ↓
GameController::handleUndoClick
    ↓
从UndoManager弹出撤销记录
    ↓
恢复GameModel数据状态
    ↓
触发CardView反向动画
    ↓
动画完成后更新GameView
```

### 3.5 Managers层 - 管理器

#### UndoManager (撤销管理器)
**职责**: 管理撤销操作的历史记录

**设计原则**:
- 作为Controller的成员变量(非单例)
- 可持有Model数据
- 不反向依赖Controller
- 通过回调接口与其他模块交互

**核心方法**:
- `addUndo(const UndoModel&)`: 添加撤销记录
- `popUndo(UndoModel& outModel)`: 弹出撤销记录
- `canUndo()`: 判断是否可撤销
- `clear()`: 清空撤销记录

**数据结构**:
```cpp
std::vector<UndoModel> _undoStack;  // 撤销栈
```

### 3.6 Services层 - 服务层

#### GameModelGenerator (游戏数据生成服务)
**职责**: 将静态配置转换为运行时动态数据

**设计原则**:
- 无状态服务(不持有数据)
- 提供静态方法
- 通过参数传递数据

**核心方法**:
```cpp
static GameModel* generateFromLevelConfig(const LevelConfig*)
```

**处理逻辑**:
1. 从LevelConfig读取配置
2. 为每张卡牌生成唯一ID
3. 创建CardModel对象
4. 构建GameModel结构
5. 初始化底牌为备用牌堆第一张

### 3.7 Utils层 - 工具类

#### CardMatchUtils (卡牌匹配工具)
**职责**: 提供卡牌匹配规则判断

**匹配规则**:
- 点数差值为1即可匹配
- 无花色限制
- 支持A和K的循环匹配

**核心方法**:
```cpp
static bool canMatch(const CardModel* card1, const CardModel* card2)
static bool canMatchWithTray(const CardModel* card, const CardModel* trayCard)
```

**实现细节**:
```cpp
int getFaceDifference(int face1, int face2) {
    int normalDiff = abs(face1 - face2);
    int circularDiff = 13 - normalDiff;
    return min(normalDiff, circularDiff);
}
```

## 四、数据流和交互

### 4.1 游戏初始化流程

```
AppDelegate::applicationDidFinishLaunching
    ↓
创建Scene
    ↓
创建GameController
    ↓
GameController::startGame(levelId, scene)
    ↓
LevelConfigLoader加载关卡配置
    ↓
GameModelGenerator生成GameModel
    ↓
创建UndoManager
    ↓
创建GameView并注册回调
    ↓
GameView创建各子视图
    ↓
游戏开始运行
```

### 4.2 用户交互流程

**点击主牌区卡牌**:
```
用户点击 → CardView触摸事件 → 回调playfieldCallback
    ↓
GameController::handlePlayfieldCardClick
    ↓
CardMatchUtils判断是否可匹配
    ↓
创建UndoModel并添加到UndoManager
    ↓
GameModel数据更新
    ↓
CardView播放移动动画
    ↓
动画完成回调 → GameView更新底牌显示
```

**点击备用牌堆**:
```
用户点击 → CardView触摸事件 → 回调stackCallback
    ↓
GameController::handleStackCardClick
    ↓
创建UndoModel并添加到UndoManager
    ↓
GameModel数据更新
    ↓
CardView播放移动动画
    ↓
动画完成回调 → GameView更新底牌显示
```

**点击撤销按钮**:
```
用户点击 → Button点击事件 → 回调undoCallback
    ↓
GameController::handleUndoClick
    ↓
UndoManager::popUndo获取撤销数据
    ↓
GameModel恢复数据状态
    ↓
CardView播放反向移动动画
    ↓
动画完成回调 → GameView恢复显示
```

## 五、扩展指南

### 5.1 如何添加新卡牌

1. **添加卡牌资源**:
   - 将卡牌图片放入 `Resources/res/` 目录
   - 按照命名规范: `big_{color}_{face}.png`, `small_{color}_{face}.png`

2. **更新CardResConfig**:
   ```cpp
   // 如果是新的花色，在 getCardSuitPath 中添加
   static const char* kSuitNames[] = {"club", "diamond", "heart", "spade", "new_suit"};

   // 如果是新的点数，在枚举中添加
   enum CardFaceType {
       CFT_ACE, ... CFT_KING, CFT_NEW_FACE
   };
   ```

3. **更新关卡配置**:
   ```json
   {
       "Playfield": [
           {
               "CardFace": 13,  // 新卡牌的点数
               "CardSuit": 4,   // 新卡牌的花色
               "Position": {"x": 500, "y": 800}
           }
       ]
   }
   ```

4. **测试**:
   - 编译运行，检查新卡牌是否正确显示
   - 测试匹配规则是否适用

### 5.2 如何添加新的撤销功能类型

1. **定义新的操作类型**:
   ```cpp
   // 在 UndoModel.h 中
   enum UndoActionType {
       UAT_PLAYFIELD_TO_TRAY,
       UAT_STACK_TO_TRAY,
       UAT_NEW_ACTION_TYPE  // 新的操作类型
   };
   ```

2. **扩展UndoModel数据**:
   ```cpp
   class UndoModel {
   private:
       // 现有成员...
       int _newActionData;  // 新操作需要的额外数据
   public:
       int getNewActionData() const { return _newActionData; }
       void setNewActionData(int data) { _newActionData = data; }
   };
   ```

3. **在Controller中记录新操作**:
   ```cpp
   void GameController::handleNewAction() {
       // 执行操作前记录撤销信息
       UndoModel undoModel(UAT_NEW_ACTION_TYPE, ...);
       undoModel.setNewActionData(someValue);
       _undoManager->addUndo(undoModel);

       // 执行操作...
   }
   ```

4. **实现撤销逻辑**:
   ```cpp
   void GameController::handleUndoClick() {
       UndoModel undoModel;
       if (_undoManager->popUndo(undoModel)) {
           switch(undoModel.getActionType()) {
               case UAT_NEW_ACTION_TYPE:
                   executeNewUndo(undoModel);
                   break;
               // 其他case...
           }
       }
   }

   void GameController::executeNewUndo(const UndoModel& undoModel) {
       // 实现新操作的撤销逻辑
   }
   ```

### 5.3 如何添加新的游戏模式

1. **创建新的Controller**:
   ```cpp
   // NewGameModeController.h
   class NewGameModeController {
   private:
       GameModel* _gameModel;
       NewGameModeView* _view;
   public:
       bool startGame(int levelId, Node* parent);
       void handleSpecialAction();
   };
   ```

2. **创建对应的View**:
   ```cpp
   // NewGameModeView.h
   class NewGameModeView : public Layer {
   public:
       static NewGameModeView* create(...);
       void showSpecialUI();
   };
   ```

3. **复用现有组件**:
   - 可以继续使用 GameModel, CardModel 等数据模型
   - 可以复用 CardView 等基础视图组件
   - 可以使用 UndoManager 等管理器

4. **在AppDelegate中切换**:
   ```cpp
   // 根据配置选择不同的Controller
   if (gameMode == CLASSIC) {
       GameController* controller = new GameController();
       controller->startGame(levelId, scene);
   } else if (gameMode == NEW_MODE) {
       NewGameModeController* controller = new NewGameModeController();
       controller->startGame(levelId, scene);
   }
   ```

## 六、项目文件清单

### 核心代码文件
```
Classes/
├── configs/
│   ├── models/CardResConfig.h/cpp
│   ├── models/LevelConfig.h/cpp
│   └── loaders/LevelConfigLoader.h/cpp
├── models/
│   ├── CardModel.h/cpp
│   ├── GameModel.h/cpp
│   └── UndoModel.h/cpp
├── views/
│   ├── CardView.h/cpp
│   └── GameView.h/cpp
├── controllers/
│   └── GameController.h/cpp
├── managers/
│   └── UndoManager.h/cpp
├── services/
│   └── GameModelGenerator.h/cpp
├── utils/
│   └── CardMatchUtils.h/cpp
└── AppDelegate.cpp/h
```

### 资源文件
```
Resources/
├── levels/
│   └── level_1.json
└── res/
    ├── card_general.png
    ├── suits/
    │   ├── club.png
    │   ├── diamond.png
    │   ├── heart.png
    │   └── spade.png
    └── number/
        ├── big_black_A.png
        ├── big_red_A.png
        ├── small_black_A.png
        └── ... (其他数字图片)
```

